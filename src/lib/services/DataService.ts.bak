// src/lib/services/DataService.ts
// PROFESSIONELLER SERVICE LAYER f√ºr Multi-Source Financial Data

export interface DividendDataPoint {
    date: string
    amount: number
    source: 'fmp' | 'finnhub' | 'alpha_vantage' | 'merged'
    confidence: number // 0-100
  }
  
  export interface DataQuality {
    score: number // 0-100
    issues: string[]
    sources: string[]
    coverage: number // percentage of expected data points
  }
  
  export interface StockQuote {
    price: number
    change: number
    changePercent: number
    volume: number
    marketCap: number
    source: string
    timestamp: number
  }
  
  // ‚îÄ‚îÄ‚îÄ HAUPTKLASSE: DataService ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  export class DataService {
    private fmpKey: string
    private finnhubKey: string
    private alphaKey?: string
  
    constructor() {
      this.fmpKey = process.env.NEXT_PUBLIC_FMP_API_KEY || ''
      this.finnhubKey = process.env.NEXT_PUBLIC_FINNHUB_API_KEY || ''
      this.alphaKey = process.env.NEXT_PUBLIC_ALPHA_VANTAGE_KEY
    }
  
    // ‚úÖ HAUPTMETHODE: Intelligente Dividendendaten mit Multi-Source
    async getDividendData(ticker: string): Promise<{
      historical: Record<string, number>
      rawData: {
        fmp: DividendDataPoint[]
        finnhub: DividendDataPoint[]
        alphaVantage: DividendDataPoint[]
      }
      quality: DataQuality
      recommendations: string[]
    }> {
      console.log(`üîç [DataService] Loading dividend data for ${ticker}`)
      
      // Parallel laden aller Quellen
      const [fmpData, finnhubData, alphaData] = await Promise.allSettled([
        this.getFMPDividends(ticker),
        this.getFinnhubDividends(ticker),
        this.getAlphaVantageDividends(ticker)
      ])
  
      // Daten extrahieren
      const fmpDividends = fmpData.status === 'fulfilled' ? fmpData.value : []
      const finnhubDividends = finnhubData.status === 'fulfilled' ? finnhubData.value : []
      const alphaDividends = alphaData.status === 'fulfilled' ? alphaData.value : []
  
      console.log(`üìä Data Sources: FMP=${fmpDividends.length}, Finnhub=${finnhubDividends.length}, Alpha=${alphaDividends.length}`)
  
      // Intelligente Daten-Fusion
      const { merged, quality } = this.mergeDividendData(fmpDividends, finnhubDividends, alphaDividends)
      
      // Empfehlungen basierend auf Datenqualit√§t
      const recommendations = this.generateDataRecommendations(quality, ticker)
  
      return {
        historical: merged,
        rawData: {
          fmp: fmpDividends,
          finnhub: finnhubDividends,
          alphaVantage: alphaDividends
        },
        quality,
        recommendations
      }
    }
  
    // ‚úÖ FMP Dividendendaten
    private async getFMPDividends(ticker: string): Promise<DividendDataPoint[]> {
      try {
        const response = await fetch(
          `https://financialmodelingprep.com/api/v3/historical-price-full/stock_dividend/${ticker}?apikey=${this.fmpKey}`
        )
        
        if (!response.ok) throw new Error(`FMP HTTP ${response.status}`)
        
        const data = await response.json()
        const historical = data[0]?.historical || data.historical || []
        
        // Nach Jahren gruppieren und Quartale z√§hlen
        const yearlyData: Record<string, { payments: DividendDataPoint[], total: number }> = {}
        const currentYear = new Date().getFullYear()
        
        historical.forEach((div: any) => {
          const year = div.date.slice(0, 4)
          const yearNum = parseInt(year)
          
          // ‚úÖ KRITISCHER FIX: 2025 und Zukunftsjahre ausschlie√üen
          if (yearNum >= currentYear) return
          
          const amount = div.dividend || div.adjDividend || 0
          
          if (!yearlyData[year]) {
            yearlyData[year] = { payments: [], total: 0 }
          }
          
          yearlyData[year].payments.push({
            date: div.date,
            amount,
            source: 'fmp',
            confidence: 85
          })
          yearlyData[year].total += amount
        })
  
        // Konfidenz anpassen basierend auf Quartalszahlen
        const result: DividendDataPoint[] = []
        Object.entries(yearlyData).forEach(([year, data]) => {
          const quarterCount = data.payments.length
          
          // Niedrigere Konfidenz f√ºr vergangene Jahre mit < 4 Quartalen
          let confidence = 85
          if (quarterCount < 4) {
            confidence = 60
            console.warn(`‚ö†Ô∏è FMP ${year}: Nur ${quarterCount} Quartale - m√∂glicherweise unvollst√§ndig`)
          }
          
          result.push({
            date: `${year}-12-31`,
            amount: data.total,
            source: 'fmp',
            confidence
          })
        })
  
        console.log(`‚úÖ FMP: ${result.length} Jahre geladen (ohne ${currentYear}+)`)
        return result
        
      } catch (error) {
        console.error('‚ùå FMP Dividends failed:', error)
        return []
      }
    }
  
    // ‚úÖ Finnhub Dividendendaten
    private async getFinnhubDividends(ticker: string): Promise<DividendDataPoint[]> {
      try {
        const response = await fetch(
          `https://finnhub.io/api/v1/stock/dividend?symbol=${ticker}&token=${this.finnhubKey}`
        )
        
        if (!response.ok) throw new Error(`Finnhub HTTP ${response.status}`)
        
        const dividends = await response.json()
        
        if (!Array.isArray(dividends)) {
          console.warn('‚ö†Ô∏è Finnhub returned non-array response')
          return []
        }
  
        // Nach Jahren gruppieren
        const yearlyData: Record<string, number> = {}
        const currentYear = new Date().getFullYear()
        
        dividends.forEach((div: any) => {
          const year = div.date.slice(0, 4)
          const yearNum = parseInt(year)
          
          // ‚úÖ KRITISCHER FIX: 2025 und Zukunftsjahre ausschlie√üen
          if (yearNum >= currentYear) return
          
          const amount = div.amount || 0
          yearlyData[year] = (yearlyData[year] || 0) + amount
        })
  
        const result: DividendDataPoint[] = Object.entries(yearlyData).map(([year, total]) => ({
          date: `${year}-12-31`,
          amount: total,
          source: 'finnhub',
          confidence: 90
        }))
  
        console.log(`‚úÖ Finnhub: ${result.length} Jahre geladen (ohne ${currentYear}+)`)
        return result
        
      } catch (error) {
        console.error('‚ùå Finnhub Dividends failed:', error)
        return []
      }
    }
  
    // ‚úÖ Alpha Vantage Dividendendaten
    private async getAlphaVantageDividends(ticker: string): Promise<DividendDataPoint[]> {
      if (!this.alphaKey) return []
      
      try {
        const response = await fetch(
          `https://www.alphavantage.co/query?function=DIVIDENDS&symbol=${ticker}&apikey=${this.alphaKey}`
        )
        
        if (!response.ok) throw new Error(`Alpha Vantage HTTP ${response.status}`)
        
        const data = await response.json()
        
        if (data['Error Message']) {
          console.warn('‚ö†Ô∏è Alpha Vantage:', data['Error Message'])
          return []
        }
        
        if (!data.data || !Array.isArray(data.data)) return []
  
        // Nach Jahren gruppieren
        const yearlyData: Record<string, number> = {}
        const currentYear = new Date().getFullYear()
        
        data.data.forEach((div: any) => {
          const year = div.ex_dividend_date.slice(0, 4)
          const yearNum = parseInt(year)
          
          // ‚úÖ KRITISCHER FIX: 2025 und Zukunftsjahre ausschlie√üen
          if (yearNum >= currentYear) return
          
          const amount = parseFloat(div.amount || 0)
          yearlyData[year] = (yearlyData[year] || 0) + amount
        })
  
        const result: DividendDataPoint[] = Object.entries(yearlyData).map(([year, total]) => ({
          date: `${year}-12-31`,
          amount: total,
          source: 'alpha_vantage',
          confidence: 90
        }))
  
        console.log(`‚úÖ Alpha Vantage: ${result.length} Jahre geladen (ohne ${currentYear}+)`)
        return result
        
      } catch (error) {
        console.error('‚ùå Alpha Vantage Dividends failed:', error)
        return []
      }
    }
  
    // ‚úÖ INTELLIGENTE DATEN-FUSION (mit 2025 Filter)
    private mergeDividendData(
      fmpData: DividendDataPoint[], 
      finnhubData: DividendDataPoint[], 
      alphaData: DividendDataPoint[]
    ): { merged: Record<string, number>, quality: DataQuality } {
      
      const currentYear = new Date().getFullYear()
      
      // ‚úÖ Nur vergangene Jahre verwenden
      const allYears = new Set([
        ...fmpData.filter(d => parseInt(d.date.slice(0, 4)) < currentYear).map(d => d.date.slice(0, 4)),
        ...finnhubData.filter(d => parseInt(d.date.slice(0, 4)) < currentYear).map(d => d.date.slice(0, 4)),
        ...alphaData.filter(d => parseInt(d.date.slice(0, 4)) < currentYear).map(d => d.date.slice(0, 4))
      ])
  
      const merged: Record<string, number> = {}
      const issues: string[] = []
      let qualityScore = 100
      const sources: string[] = []
  
      allYears.forEach(year => {
        const fmpEntry = fmpData.find(d => d.date.slice(0, 4) === year)
        const finnhubEntry = finnhubData.find(d => d.date.slice(0, 4) === year)
        const alphaEntry = alphaData.find(d => d.date.slice(0, 4) === year)
  
        // Sammle verf√ºgbare Quellen
        const yearSources: Array<{source: string, amount: number, confidence: number}> = []
        if (fmpEntry) yearSources.push({source: 'FMP', amount: fmpEntry.amount, confidence: fmpEntry.confidence})
        if (finnhubEntry) yearSources.push({source: 'Finnhub', amount: finnhubEntry.amount, confidence: finnhubEntry.confidence})
        if (alphaEntry) yearSources.push({source: 'Alpha', amount: alphaEntry.amount, confidence: alphaEntry.confidence})
  
        if (yearSources.length === 0) return
  
        // F√ºge Quellen zur Gesamtliste hinzu
        yearSources.forEach(s => {
          if (!sources.includes(s.source)) sources.push(s.source)
        })
  
        if (yearSources.length === 1) {
          // Nur eine Quelle verf√ºgbar
          merged[year] = yearSources[0].amount
          if (yearSources[0].confidence < 80) {
            issues.push(`${year}: Nur ${yearSources[0].source} verf√ºgbar (Konfidenz: ${yearSources[0].confidence}%)`)
            qualityScore -= 5
          }
        } else {
          // Mehrere Quellen - Vergleiche sie
          const amounts = yearSources.map(s => s.amount)
          const avgAmount = amounts.reduce((sum, a) => sum + a, 0) / amounts.length
          const maxDiff = Math.max(...amounts) - Math.min(...amounts)
          const percentDiff = maxDiff / avgAmount * 100
  
          if (percentDiff < 5) {
            // Sehr √§hnlich - verwende die Quelle mit h√∂chster Konfidenz
            const bestSource = yearSources.reduce((best, current) => 
              current.confidence > best.confidence ? current : best
            )
            merged[year] = bestSource.amount
          } else if (percentDiff < 15) {
            // Kleine Abweichung - verwende Durchschnitt gewichtet nach Konfidenz
            const weightedSum = yearSources.reduce((sum, s) => sum + (s.amount * s.confidence), 0)
            const totalWeight = yearSources.reduce((sum, s) => sum + s.confidence, 0)
            merged[year] = weightedSum / totalWeight
            
            issues.push(`${year}: Kleine Abweichung zwischen Quellen (${percentDiff.toFixed(1)}%)`)
            qualityScore -= 3
          } else {
            // Gro√üe Abweichung - verwende Finnhub wenn verf√ºgbar, sonst beste Konfidenz
            const finnhubSource = yearSources.find(s => s.source === 'Finnhub')
            if (finnhubSource) {
              merged[year] = finnhubSource.amount
            } else {
              const bestSource = yearSources.reduce((best, current) => 
                current.confidence > best.confidence ? current : best
              )
              merged[year] = bestSource.amount
            }
            
            issues.push(`${year}: Gro√üe Abweichung zwischen Quellen (${percentDiff.toFixed(1)}%) - ${yearSources.map(s => `${s.source}: $${s.amount.toFixed(4)}`).join(', ')}`)
            qualityScore -= 10
          }
        }
      })
  
      // Coverage berechnen
      const expectedYears = 20 // Erwarte 20 Jahre Dividendendaten
      const coverage = Math.min(100, (Object.keys(merged).length / expectedYears) * 100)
  
      const quality: DataQuality = {
        score: Math.max(0, qualityScore),
        issues,
        sources,
        coverage
      }
  
      console.log(`üìä Data Fusion Complete: ${Object.keys(merged).length} Jahre, Quality Score: ${quality.score}/100`)
      
      return { merged, quality }
    }
  
    // ‚úÖ EMPFEHLUNGEN basierend auf Datenqualit√§t
    private generateDataRecommendations(quality: DataQuality, ticker: string): string[] {
      const recommendations: string[] = []
  
      if (quality.score < 70) {
        recommendations.push(`Niedrige Datenqualit√§t (${quality.score}/100) - Manuelle Verifikation empfohlen`)
      }
  
      if (quality.coverage < 80) {
        recommendations.push(`Unvollst√§ndige Abdeckung (${quality.coverage.toFixed(0)}%) - Pr√ºfe andere Datenquellen`)
      }
  
      if (quality.sources.length < 2) {
        recommendations.push(`Nur eine Datenquelle verf√ºgbar - Risiko unvollst√§ndiger Daten`)
      }
  
      if (quality.issues.some(issue => issue.includes('Gro√üe Abweichung'))) {
        recommendations.push(`Konflikte zwischen Datenquellen gefunden - Vergleiche mit ${ticker} Investor Relations`)
      }
  
      if (recommendations.length === 0) {
        recommendations.push(`Datenqualit√§t ist gut - ${quality.sources.join(', ')} stimmen √ºberein`)
      }
  
      return recommendations
    }
  
    // ‚úÖ Stock Quote mit Multi-Source
    async getStockQuote(ticker: string): Promise<StockQuote | null> {
      try {
        // Versuche FMP zuerst
        const response = await fetch(
          `https://financialmodelingprep.com/api/v3/quote/${ticker}?apikey=${this.fmpKey}`
        )
        
        if (response.ok) {
          const [quote] = await response.json()
          return {
            price: quote.price,
            change: quote.change,
            changePercent: quote.changesPercentage,
            volume: quote.volume,
            marketCap: quote.marketCap,
            source: 'FMP',
            timestamp: Date.now()
          }
        }
  
        // Fallback zu Finnhub
        const finnhubResponse = await fetch(
          `https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${this.finnhubKey}`
        )
        
        if (finnhubResponse.ok) {
          const quote = await finnhubResponse.json()
          return {
            price: quote.c,
            change: quote.d,
            changePercent: quote.dp,
            volume: 0,
            marketCap: 0,
            source: 'Finnhub',
            timestamp: quote.t * 1000
          }
        }
  
        return null
      } catch (error) {
        console.error('‚ùå Error fetching stock quote:', error)
        return null
      }
    }
  }
  
  // ‚úÖ SINGLETON EXPORT
  export const dataService = new DataService()